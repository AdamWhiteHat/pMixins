@using CopaceticSoftware.pMixins.Mvc.Extensions

@{
    ViewBag.Title = "How It Works";
}

<div class="container body-content">
    <div class="row">
        <div class="col-md-12">
            <blockquote class="pull-right">
                <p>In the real world, inheritance tends to be an antipattern</p>
                <small>
                    Kas Thomas <cite title="Big Think">
                        <a href="http://asserttrue.blogspot.nl/2009/02/inheritance-as-antipattern.html">Big Think</a>
                    </cite>
                </small>
            </blockquote>
        </div>
    </div>
    <div class="row">
        <div class="col-md-10">
            <h1>How <span class="logo-code">[<span class="typ">p</span>Mixins]</span> Works</h1>
            <p>
                <span class="logo-code">[<span class="typ">p</span>Mixins]</span> is a Visual Studio plug-in that
                scans a solution for <code>partial</code> classes decorated with <code>pMixin</code> attributes.
                By marking your class <code>partial</code>, <span class="logo-code">[<span class="typ">p</span>Mixins]</span>
                can create a <em>code-behind</em> file and add additional members to your class.
                This is the same mechanism <a href="http://www.asp.net">asp.net</a> uses to create data members for server-side controls.
                In fact, this is how <span class="logo-code">[<span class="typ">p</span>Mixins]</span>
                gets its name: <em>partial mixins</em>!
            </p>
            <h3>Design-Time Weaving</h3>
            <p>
                The process of combining the code from several classes together in AOP is called <a href="http://en.wikipedia.org/wiki/Aspect_weaver">aspect weaving.</a>.
                The most commonly occurs at either compile-time by invoking a custom compiler
                (this is the method <a href="http://www.postsharp.net/">PostSharp</a> uses) or at run-time by emitting
                specialized <em>proxy</em> objects
                (this is how <a href="http://www.castleproject.org/projects/dynamicproxy/">Castle Dynamic Proxy</a> works).
            </p>
            <p>
                Since <span class="logo-code">[<span class="typ">p</span>Mixins]</span> uses code-behind files which are generated
                as soon as the save button is clicked in Visual Studio, I have come to call this Design-Time Weaving. There are several benefits
                with this approach because with Design Tiem Weaving, the aspect weaving code is generated immediately.  This means
                that Visual Studio will give you Intellisense support.  Code analysis tools like <a href="http://www.jetbrains.com/resharper/">ReSharper</a>
                fully understand the code.  And the Compiler gives you full compile-time error checking - every line of code that could be executes
                exists <em>before</em> compilation.
            </p>
            <p>
                Design Time Weaving also, works great for teams.   If your colleagues don't want to use
                <span class="logo-code">[<span class="typ">p</span>Mixins]</span>,
                that's not a problem.  Because the code-behind files are already generated and checked into your version control system of choice
                so they don't need <span class="logo-code">[<span class="typ">p</span>Mixins]</span> installed to build or run the solution.
                And this is the same for your build server, test server, etc.
            </p>
            <p>
                Is there a down side?  Like any engineering decision there are always trade offs.  <span class="logo-code">[<span class="typ">p</span>Mixins]</span>
                does have a small NuGet <a href="https://www.nuget.org/packages/pMixins/">dependency</a>, but there is an additional Visual Studio
                plugin that will auto-add it to your projects:
                <a href="http://visualstudiogallery.msdn.microsoft.com/e2fb83fc-a6e2-46bd-a392-00f9d081b17c">pMixins - Item Template</a>.  And since
                <span class="logo-code">[<span class="typ">p</span>Mixins]</span> doesn't change the original class, the syntax can be more limited
                when compared to other frameworks, but in practice, this is rarely an issue.
            </p>
            <h3>Code Behind Walk Through</h3>
            <p>
                So let's take a look at the code-behind file generated by <span class="logo-code">[<span class="typ">p</span>Mixins]</span>.
                Down below is a simplified version of
                the code behind generated for the <em>Introduction</em> class from the
                @Html.ActionLink("Introduction", "Index", "Introduction") page.  This is a lot to digest
                in one piece, but we'll walk through it step by step futher below.
            </p>

            @Html.RenderSourceClass("Introduction/ExampleCodeBehind.cs", "Introduction")

            <strong>Mixin Wrapper Class Definitions</strong>
            <p>
                First up is the <code>__pMixinAutoGenerated</code> class.  This contains child
                class definitions for each Mixin.  In this case, we only have one, <code>HelloWorldMixin</code>, which
                in turn generates defines several wrapper classes.
            </p>
            <p>
                <span class="logo-code">[<span class="typ">p</span>Mixins]</span> uses three levels of wrapper classes
                in order to ensure all Mixin members are correctly added to the Target and are weaved into the AOP
                infrastructure:
            </p>
            <p>&nbsp;</p>
            <dl class="dl-horizontal">
                <dt><code>Protected Wrapper</code></dt>
                <dd>
                    <p>
                        This wrapper inherits from the Mixin promotes all
                        <code>protected</code> members to <code>public</code> so that the
                        <em>Master Wrapper</em> can call them.  <span class="logo-code">[<span class="typ">p</span>Mixins]</span>
                        enforces member access, so no other class can accidentally invoke these members.
                    </p>
                    <p>
                        If the Mixin is <code>sealed</code>, this wrapper is not generated.
                    </p>
                </dd>
                <dt><code>Abstract Wrapper</code></dt>
                <dd>
                    <p>
                        This wrapper inherits from the <em>Protected Member Wrapper</em> and
                        is responsible for satisfying all abstract requirements imposed by the Mixin.
                    </p>
                    <p>
                        If the Mixin is abstract, a <em>Requirements</em> interface is generated that matches
                        the signature of the abstract members.  The Target is forced to implement this interface
                        which allows the <em>Abstract Wrapper</em> to implement the <code>abstract</code>
                        members by proxying them to the Target.
                    </p>
                    <p>
                        If the Mixin is <code>sealed</code>, this wrapper is not generated.
                    </p>
                </dd>
                <dt><code>Master Wrapper</code></dt>
                <dd>
                    <p>
                        This wrapper is responsible for initializing the previous wrappers,
                        which effectively generates an instance of the Mixin (<code>_mixinInstance</code>) and
                        for proxying member calls through the <span class="logo-code">[<span class="typ">p</span>Mixins]</span>
                        AOP infrastructure.
                    </p>
                    <p>
                        Both goals are accomplished by inheriting from
                        <a href="https://github.com/ppittle/pMixins/blob/master/pMixins/Infrastructure/MasterWrapperBase.cs">
                            CopaceticSoftware.pMixins.Infrastructure.MasterWrapperBase
                        </a> which provides methods to proxy Mixin initialization (<code>Initialize</code>)
                        and member invocation (<code>ExecuteMethod</code>, <code>ExecutePropertyGet</code>, etc)
                        through the AOP infrastructure to any registered <em>Interceptors (Aspects)</em>.
                    </p>
                    <p>
                        Of special interest is the line
                        <code>base.TryActivateMixin&lt;helloworldabstractwrapper&gt;(_target)</code> which transfers
                        responsibility for creating an instance of the Mixin to the <em>MixinActivatorFactory</em>.
                        This is an extensibility point where a custom (ie Dependency Injector) Activator could be plugged in.
                    </p>
                </dd>
            </dl>


            <strong>The __Mixins Class</strong>
            <p>
                Next is the <code>__Mixins</code> class, which is responsible for creating and housing instances of
                <em>Master Wrapper</em>s.  It again requests an Activator from
                <code>MixinActivatorFactory.GetCurrentActivator()</code> and uses that to create instances of the
                <em>Master Wrapper</em>s.
            </p>
            <p>
                A <code>private</code> Property (and backing field) are also created to house an
                instance of a <em>__Mixin</em> object.  The field is lazily intialized so Mixin objects
                are not created until they are needed.  Note:  Thead syncronization code has been
                removed from this example.
            </p>
            <p>&nbsp;</p>
            <strong>Member Proxying</strong>
            <p>
                After that we get to the <code>SayHello</code> method declared at the <em>Introduction</em> scope.
                This proxies call through the <code>__mixins</code> Property to the instance of the
                <code>HelloWorldMasterWrapper</code>.
            </p>
            <p>&nbsp;</p>
            <strong>Conversion Operators</strong>
            <p>
                Finally we end with a conversion operator which allows an instance of
                <code>Introduction</code> to be passed as a <code>HelloWorld</code>.
                <br />
                <em>Note:</em>This unfortunatly doesn't allow <code>Introduction</code> to pass an
                <a href="http://msdn.microsoft.com/en-us/library/scekt9xw.aspx">is</a> or
                <a href="http://msdn.microsoft.com/en-us/library/cscsdfbt%28v=vs.110%29.aspx">as</a>
                check.  Instead, <span class="logo-code">[<span class="typ">p</span>Mixins]</span> provides
                extension methods to replace the default functionality via the <code>AsIsHelper</code>.
                <br />
                See this <a href="http://stackoverflow.com/questions/18390664/c-sharp-implicit-conversion-operator-and-is-as-operator">
                    Stackoverflow Question
                </a> for more details / discussion on this.
            </p>
            <p>&nbsp;</p>
        </div>
    </div>

</div>

//----------------------------------------------------------------------- 
// <copyright file="MixinIsAbstractWithProtectedNonParameterlessConstructorSpec.cs" company="Copacetic Software"> 
// Copyright (c) Copacetic Software.  
// <author>Philip Pittle</author> 
// <date>Sunday, February 2, 2014 3:11:42 PM</date> 
// Licensed under the Apache License, Version 2.0,
// you may not use this file except in compliance with this License.
//  
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright> 
//-----------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using CopaceticSoftware.pMixins.CodeGenerator.Tests.IntegrationTests.CompileTests.AdvancedMixinTypes;
using Other.Namespace;
using MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias = pMixins.AutoGenerated.CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor.MixinIsAbstractWithProtectedNonParameterlessConstructorSpec.AbstractWithProtectedNonParameterlessConstructorMixin.CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor;
using OtherMixinAlias = pMixins.AutoGenerated.CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor.MixinIsAbstractWithProtectedNonParameterlessConstructorSpec.Other.Namespace.OtherMixin;

namespace Other.Namespace
{
    /// <summary>
    /// Covered in:
    ///     <see cref="MixinIsAbstractWithProtectedNonParameterlessConstructor"/>
    /// </summary>
    public class OtherMixin
    {
        public string OtherMixinMethod()
        {
            return "Other Mixin Method";
        }
    }
}

namespace CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor
{
    public abstract class AbstractWithProtectedNonParameterlessConstructorMixin
    {
        protected AbstractWithProtectedNonParameterlessConstructorMixin(string s)
        {
            Console.WriteLine(s);
        }

        protected int ProtectedMethod()
        {
            return 42;
        }

        public abstract string PublicAbstractMethod();

        protected abstract string ProtectedAbstractMethod();

        public virtual string PublicVirtualMethod()
        {
            return "Mixin's PublicVirtualMethod";
        }

        protected virtual string ProtectedVirtualMethod(int i)
        {
            return "Mixin's ProtectedVirtualMethod";
        }

        public virtual string PublicVirtualProperty
        {
            get; set;
        }

        public string RegularMethod()
        {
            return "Hello World";
        }

        public static string PublicStaticMethod()
        {
            return "public static method";
        }

        protected static string ProtectedStaticMethod()
        {
            return "protected static method";
        }
    }
    
    [BasicMixin(Target = typeof(AbstractWithProtectedNonParameterlessConstructorMixin))]
    [BasicMixin(Target = typeof(OtherMixin))]
    public partial class MixinIsAbstractWithProtectedNonParameterlessConstructorSpec
    {
        public MixinIsAbstractWithProtectedNonParameterlessConstructorSpec()
        {
            ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.PublicVirtualMethodFunc = () => "Target's Public Virtual Method";
        }

        MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::AbstractWrapper MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::
            IAbstractWithProtectedNonParameterlessConstructorMixinRequirements.InitializeMixin()
        {
            return new MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::AbstractWrapper(this, "");
        }

        string MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::
            IAbstractWithProtectedNonParameterlessConstructorMixinRequirements.PublicAbstractMethodImplementation()
        {
            return "Target-PublicAbstractMethod";
        }

        string MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::
            IAbstractWithProtectedNonParameterlessConstructorMixinRequirements.ProtectedAbstractMethodImplementation()
        {
            return "Target-ProtectedAbstractMethod";
        }
    }
}


/*/////////////////////////////////////////
/// Generated Code
/////////////////////////////////////////*/
// ReSharper disable InconsistentNaming
// ReSharper disable IdentifierTypo
// ReSharper disable RedundantNameQualifier
// ReSharper disable UnusedMember.Global
// ReSharper disable ClassNeverInstantiated.Global

//namespace format: "pMixin.AutoGenerated." + Target.FullName + "." + Mixin.FullName
namespace
    pMixins.AutoGenerated.CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor.
    MixinIsAbstractWithProtectedNonParameterlessConstructorSpec.AbstractWithProtectedNonParameterlessConstructorMixin
    .CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor
{
    [GeneratedCode("pMixin", "1.0.0.0")]
    public abstract class ProtectedMembersWrapper : 
        global::CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor.
        AbstractWithProtectedNonParameterlessConstructorMixin
    {
        public ProtectedMembersWrapper(string s) : base(s)
        {
        }

        // "New" keyword is required
        public new int ProtectedMethod()
        {
            return base.ProtectedMethod();
        }
        
        public new virtual string ProtectedVirtualMethod(int i)
        {
            return base.ProtectedVirtualMethod(i);
        }

        //Upgrade static members as well.  "New" keyword is required.
        public new static string ProtectedStaticMethod()
        {
            return "protected static method";
        }
    }

    [GeneratedCode("pMixin", "1.0.0.0")]
    public interface IAbstractWithProtectedNonParameterlessConstructorMixinRequirements
    {
        //If Mixin has a public constructor and no protected members, could downgrade this method to 
        //return the Mixin itself, as the MasterWrapper could wrap all members.
        AbstractWrapper InitializeMixin();

        //Must give this is a different name from AbstractWithProtectedNonParameterlessConstructorMixin.AbstractMethod
        //otherwise the 'injected' version of the method will satisfy the requirement
        string PublicAbstractMethodImplementation();

        string ProtectedAbstractMethodImplementation();
    }

    /// <summary>
    /// Proxy abstract methods to _target, via the IRequirements interface
    /// </summary>
    [GeneratedCode("pMixin", "1.0.0.0")]
    public class AbstractWrapper : ProtectedMembersWrapper
    {
        private readonly IAbstractWithProtectedNonParameterlessConstructorMixinRequirements _target;

        //Add a helpful comment because Target will use this constructor
        /// <summary>
        /// Creates a new Instance of the wrapper for <see cref="AbstractWithProtectedNonParameterlessConstructorMixin"/>.
        /// This constructor is recommended for use to implement <see cref="IAbstractWithProtectedNonParameterlessConstructorMixinRequirements.InitializeMixin"/>
        /// </summary>
        /// <param name="target">Pass in <c>this</c></param>
        /// <param name="s"></param>
        public AbstractWrapper(IAbstractWithProtectedNonParameterlessConstructorMixinRequirements target, string s)
            : base(s)
        {
            _target = target;
        }

        public override string PublicAbstractMethod()
        {
            return _target.PublicAbstractMethodImplementation();
        }
        
        protected override string ProtectedAbstractMethod()
        {
            return _target.ProtectedAbstractMethodImplementation();
        }

        public string ProtectedAbstractMethodPublic()
        {
            return ProtectedAbstractMethod();
        }
    }
    

    /// Provide a simple constructor that only takes an instance of the IRequirements interface
    /// to build an instance of the AbstractWrapper.  Additionally, exposes a 
    /// mechanism for Target to override Mixin's virtual members  Makes sense to be sealed?
  [GeneratedCode("pMixin", "1.0.0.0")]
    public sealed class MasterWrapper
    {
        //must be public for static conversions
        public readonly AbstractWrapper AbstractWrapper;

        public MasterWrapper(IAbstractWithProtectedNonParameterlessConstructorMixinRequirements target)
        {
            AbstractWrapper = target.InitializeMixin();

            PublicVirtualMethodFunc = delegate() { return AbstractWrapper.PublicVirtualMethod(); };
            ProteectedVirtualMethodFunc = delegate(int i) { return AbstractWrapper.ProtectedVirtualMethod(i); }; 

            PublicVirtaulPropertyGetFunc = () => AbstractWrapper.PublicVirtualProperty;
            PublicVirtualPropertySetFunc = (s) => AbstractWrapper.PublicVirtualProperty = s;
        }
        
        //Make all members public in wrappers
        public int ProtectedMethod()
        {
            return AbstractWrapper.ProtectedMethod();
        }

        public string PublicAbstractMethod()
        {
            return AbstractWrapper.PublicAbstractMethod();
        }

        public string ProtectedAbstractMethod()
        {
            return AbstractWrapper.ProtectedAbstractMethodPublic();
        }

        /// Must be public. Provides a mechanism for Target to overload the implementation.
        /// Set to point to <see cref="AbstractWrapper"/>'s implementation 
        /// in constructor of MasterWrapper
        public System.Func<string> PublicVirtualMethodFunc { get; set; }
        public string PublicVirtualMethod()
        {
            return PublicVirtualMethodFunc();
        }

        public System.Func<int,string> ProteectedVirtualMethodFunc { get; set; }
        public string ProtectedVirtualMethod(int i)
        {
            return ProteectedVirtualMethodFunc(i);
        }

        public System.Func<string> PublicVirtaulPropertyGetFunc { get; set; }
        public System.Action<string> PublicVirtualPropertySetFunc { get; set; } 
        public string PublicVirtualProperty
        {
            get { return PublicVirtaulPropertyGetFunc(); }
            set { PublicVirtualPropertySetFunc(value); }
        }


        public string RegularMethod()
        {
            return AbstractWrapper.RegularMethod();
        }

        //////Static methods don't need to be wrapped, but could be for simplicity
        public static string PublicStaticMethod()
        {
            return global::CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor
                .AbstractWithProtectedNonParameterlessConstructorMixin.PublicStaticMethod();
        }

        public static string ProtectedStaticMethod()
        {
            //Protected static methods have to come from the ProtectedMembersWrapper
            return ProtectedMembersWrapper.ProtectedStaticMethod();
        }
    }
}

namespace
    pMixins.AutoGenerated.CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor.
        MixinIsAbstractWithProtectedNonParameterlessConstructorSpec.
        Other.Namespace.OtherMixin
{
    [GeneratedCode("pMixin", "1.0.0.0")]
    public abstract class ProtectedMembersWrapper : global::Other.Namespace.OtherMixin { }

    [GeneratedCode("pMixin", "1.0.0.0")]
    public interface IOtherMixinRequirements{}

    [GeneratedCode("pMixin", "1.0.0.0")]
    public class AbstractWrapper : ProtectedMembersWrapper
    {
    }

    [GeneratedCode("pMixin", "1.0.0.0")]
    public sealed class MasterWrapper
    {
        //must be public for static conversions
        public readonly AbstractWrapper AbstractWrapper;

        public MasterWrapper(IOtherMixinRequirements target)
        {
            //MixinAttribute.RequiresInitialization = false, so we can construct
            //AbstractWrapper directly
            AbstractWrapper = new AbstractWrapper();
        }

        public string OtherMixinMethod()
        {
            return AbstractWrapper.OtherMixinMethod();
        }
    }
}

namespace CopaceticSoftware.pMixins.TheorySandbox.MixinIsAbstractWithProtectedNonParameterlessConstructor
{
    [GeneratedCode("pMixin", "1.0.0.0")]
    public partial class MixinIsAbstractWithProtectedNonParameterlessConstructorSpec :
        MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::
            IAbstractWithProtectedNonParameterlessConstructorMixinRequirements,
        OtherMixinAlias::
            IOtherMixinRequirements
    {
        private sealed class __Mixins
        {
            public static readonly global::System.Object ____Lock = new global::System.Object();

            public readonly MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::MasterWrapper 
                MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper;

            public readonly OtherMixinAlias::MasterWrapper
                OtherMixinMasterWrapper;
            
            public __Mixins(MixinIsAbstractWithProtectedNonParameterlessConstructorSpec target)
            {
                MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper = new DefaultMixinActivator().CreateInstance<
                    MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::MasterWrapper>(
                    //Explicit cast to Requirements interface so interface can be implemented explicitly
                    (MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::
                        IAbstractWithProtectedNonParameterlessConstructorMixinRequirements)target);

                OtherMixinMasterWrapper = new DefaultMixinActivator().CreateInstance
                    <OtherMixinAlias::MasterWrapper>((OtherMixinAlias::IOtherMixinRequirements) target);
            }
        }

        private __Mixins _____mixins;
        private __Mixins ___mixins
        {
            get
            {
                if (null == _____mixins)
                {
                    lock (__Mixins.____Lock)
                    {
                        if (null == _____mixins)
                        {
                            _____mixins = new __Mixins(this);
                        }
                    }
                }
                return _____mixins;
            }
        }

        //Restore protected modifier
        protected int ProtectedMethod()
        {
            return ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.ProtectedMethod();
        }
        
        //Must be virtual (wrapping abstract member)
        public virtual string PublicAbstractMethod()
        {
            return ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.PublicAbstractMethod();
        }

        protected virtual string ProtectedAbstractMethod()
        {
            return ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.ProtectedAbstractMethod();
        }

        public virtual string PublicVirtualMethod()
        {
            return ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.PublicVirtualMethod();
        }

        protected virtual string ProtectedVirtualMethod(int i)
        {
            return ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.ProtectedVirtualMethod(i);
        }

        public virtual string PublicVirtualProperty
        {
            get
            {
                return
                    ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.PublicVirtualProperty;
            }
            set
            {
                ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.PublicVirtualProperty = value;
            }
        }

        public string RegularMethod()
        {
            return ___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.RegularMethod();
        }

        //public static method doesn't need to be wrapped in a wrapper
        //class and can be called directly from the Target class.
        public static string PublicStaticMethod()
        {
            return AbstractWithProtectedNonParameterlessConstructorMixin.PublicStaticMethod();
            //////Static methods don't need to be wrapped, but could be for simplicity
            //return MasterWrapper.PublicStaticMethod();
        }

        protected static string ProtectedStaticMethod()
        {
            return MixinIsAbstractWithProtectedNonParameterlessConstructorSpecAlias::ProtectedMembersWrapper.ProtectedStaticMethod();
            //////Static methods don't need to be wrapped, but could be for simplicity
            //return MasterWrapper.ProtectedStaticMethod();
        }

        public string OtherMixinMethod()
        {
            return ___mixins.OtherMixinMasterWrapper.OtherMixinMethod();
        }

        public static implicit operator AbstractWithProtectedNonParameterlessConstructorMixin(
            MixinIsAbstractWithProtectedNonParameterlessConstructorSpec target)
        {
            return target.___mixins.MixinIsAbstractWithProtectedNonParameterlessConstructorMasterWrapper.AbstractWrapper;
        }

        public static implicit operator OtherMixin(
            MixinIsAbstractWithProtectedNonParameterlessConstructorSpec target)
        {
            return target.___mixins.OtherMixinMasterWrapper.AbstractWrapper;
        }
    }
}
// ReSharper restore InconsistentNaming
// ReSharper restore IdentifierTypo
// ReSharper restore RedundantNameQualifier
// ReSharper restore UnusedMember.Global
// ReSharper restore ClassNeverInstantiated.Global


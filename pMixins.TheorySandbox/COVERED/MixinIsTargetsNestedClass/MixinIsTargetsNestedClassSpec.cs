//----------------------------------------------------------------------- 
// <copyright file="MixinIsTargetsNestedClassSpec.cs" company="Copacetic Software"> 
// Copyright (c) Copacetic Software.  
// <author>Philip Pittle</author> 
// <date>Thursday, February 20, 2014 8:58:00 PM</date> 
// Licensed under the Apache License, Version 2.0,
// you may not use this file except in compliance with this License.
//  
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright> 
//-----------------------------------------------------------------------

using CopaceticSoftware.pMixins.CodeGenerator.Tests.IntegrationTests.CompileTests.AdvancedMixinTypes;
using CopaceticSoftware.pMixins.TheorySandbox.COVERED.AsIsWrapper;

namespace CopaceticSoftware.pMixins.TheorySandbox.COVERED.MixinIsTargetsNestedClass
{ //TODO:  Because Mixin is nested and listed as private, we can't create 
//wrapper classes in a separate namespace.  Investigate if it's ok 
//to create them in a nested class.

    /// <summary>
    /// Covered by:
    ///     <see cref="MixinIsPrivateNestedTypeInTarget"/>
    /// </summary>
    public class BaseClass
    {
        public string BaseMethod()
        {
            return "Base Method";
        }
    }

    public interface IInterface
    {
        string IInterfaceMethod();
    }

    /// <summary>
    /// Covered by:
    ///     <see cref="MixinIsPrivateNestedTypeInTarget"/>
    /// </summary>
    [BasicMixin(Target = typeof(MixinIsTargetsNestedClassSpec.PrivateMixin))]
    public partial class MixinIsTargetsNestedClassSpec
    {
        private class PrivateMixin : BaseClass, IInterface
        {
            public PrivateMixin(string name)
            {
            }

            public string MixinMethod()
            {
                return "Nested Private Mixin";
            }

            public string IInterfaceMethod()
            {
                return "IInterfaceMethod";
            }
        }

        
        PrivateMixin IMixinConstructorRequirement<MixinIsTargetsNestedClassSpec.PrivateMixin>.InitializeMixin()
        {
            return new PrivateMixin("");
        }
        
    }

    interface IMixinConstructorRequirement<out TMixin>
    {
        TMixin InitializeMixin();
    }

/*/////////////////////////////////////////
/// Generated Code
/////////////////////////////////////////*/

    public partial class MixinIsTargetsNestedClassSpec :
        IMixinConstructorRequirement<MixinIsTargetsNestedClassSpec.PrivateMixin>,
        IWrap<MixinIsTargetsNestedClassSpec.PrivateMixin>,
        IInterface // inherit from mixin's interfaces
    {
        private class __pMixinAutoGenerated
        {
            public class CopaceticSoftware_pMixin_TheorySandbox_MixinIsTargetsNestedClass_PrivateMixin
            {
                //don't need protected wrapper

                //don't need abstract wrapper

                public sealed class MasterWrapper
                {
                    public readonly PrivateMixin PrivateMixin;

                    public MasterWrapper(MixinIsTargetsNestedClassSpec target)
                    {
                        this.PrivateMixin = 
                            ((IMixinConstructorRequirement<MixinIsTargetsNestedClassSpec.PrivateMixin>)target)
                                .InitializeMixin();
                    }

                    public string BaseMethod()
                    {
                        return PrivateMixin.BaseMethod();
                    }

                    public string MixinMethod()
                    {
                        return PrivateMixin.MixinMethod();
                    }

                    public string IInterfaceMethod()
                    {
                        return PrivateMixin.IInterfaceMethod();
                    }
                }
            }
        }

        private sealed partial class __Mixins
        {
            public static readonly global::System.Object ____Lock = new global::System.Object();

            public readonly __pMixinAutoGenerated.CopaceticSoftware_pMixin_TheorySandbox_MixinIsTargetsNestedClass_PrivateMixin.MasterWrapper PrivateMixinMasterWrapper;

            public __Mixins(MixinIsTargetsNestedClassSpec target)
            {
                this.PrivateMixinMasterWrapper =
                    new DefaultMixinActivator()
                        .CreateInstance<__pMixinAutoGenerated.CopaceticSoftware_pMixin_TheorySandbox_MixinIsTargetsNestedClass_PrivateMixin.MasterWrapper>(
                            target);
            }
        }

        private __Mixins _____mixins;
        private __Mixins ___mixins
        {
            get
            {
                if (null == _____mixins)
                {
                    lock (__Mixins.____Lock)
                    {
                        if (null == _____mixins)
                        {
                            _____mixins = new __Mixins(this);
                        }
                    }
                }
                return _____mixins;
            }
        }

        public string BaseMethod()
        {
            return ___mixins.PrivateMixinMasterWrapper.BaseMethod();
        }
        public string MixinMethod()
        {
            return ___mixins.PrivateMixinMasterWrapper.MixinMethod();
        }

        public string IInterfaceMethod()
        {
            return ___mixins.PrivateMixinMasterWrapper.IInterfaceMethod();
        }

        /// <summary>
        /// Static implicit operator to Mixin's public base class
        /// </summary>
        public static implicit operator BaseClass(MixinIsTargetsNestedClassSpec target)
        {
            return target.___mixins.PrivateMixinMasterWrapper.PrivateMixin;
        }

        PrivateMixin IWrap<MixinIsTargetsNestedClassSpec.PrivateMixin>.GetWrappedItem()
        {
            return ___mixins.PrivateMixinMasterWrapper.PrivateMixin;
        }
    }
}